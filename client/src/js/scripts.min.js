/**
 * @ngdoc overview
 * @name miller
 * @description
 * # miller
 *
 * Main module of the application.
 */
angular
  .module('miller', [
    'ui.router',
    // 'ngAnimate',
    'ngResource',
    'ngSanitize',
    'ngCookies',
    'ngTagsInput',
    'mgcrea.ngStrap',
    'monospaced.elastic',
    'LocalStorageModule',
    'pascalprecht.translate',
    // 'angular-embedly',
    'ngDisqus',
    'angular-embed',
    'angular-embed.handlers',

    'angularLazyImg'
  ])
  .constant('LOCALES', {
    'locales': {
      'en_US': 'English'
    },
    'preferredLocale': 'en_US'
  })
  .constant('EVENTS', {
    'SAVE': 'save',
    'MESSAGE': 'message',
    'BAD_REQUEST':'bad_request',
    // namespace for markdownit directive
    'MARKDOWNIT_FULLSIZE': 'markdownit_fullsize',
    'MARKDOWNIT_RESOLVE': 'markdownit_resolve'
  })
  /*
    disqus configuration
  */
  .config(function($disqusProvider, RUNTIME) {
    if(RUNTIME.settings.disqus){
      $disqusProvider.setShortname(RUNTIME.settings.disqus);
    }

  })
  /*
    prefix
  */
  .config(function($locationProvider) {
    $locationProvider.hashPrefix('!');
  })
  /*
    multiple input tags configuration
  */
  .config(function(tagsInputConfigProvider, RUNTIME) {
    tagsInputConfigProvider
    .setDefaults('tagsInput', {
      replaceSpacesWithDashes:false,
      template: RUNTIME.static + 'templates/partials/tag.input.html' 
    })
    .setDefaults('autoComplete', {
      loadOnDownArrow: true
    });
  })
  /*
    Angular-translate configs
    Cfr. https://scotch.io/tutorials/internationalization-of-angularjs-applications
  */
  .config(function ($translateProvider, RUNTIME) {
    // $translateProvider.useMissingTranslationHandlerLog();
    $translateProvider.useSanitizeValueStrategy('sanitize');
    $translateProvider.useStaticFilesLoader({
        prefix: RUNTIME.static + 'locale/locale-',// path to translations files
        suffix: '.json'// suffix, currently- extension of the translations
    });
    $translateProvider.preferredLanguage('en_US');// is applied on first load
    
  })
  .config(function (localStorageServiceProvider) {
    localStorageServiceProvider
      .setPrefix('miller');
  })
  .config(function($resourceProvider) {
    $resourceProvider.defaults.stripTrailingSlashes = false;
  })
  .config(function($httpProvider) {
    $httpProvider.defaults.xsrfCookieName = 'csrftoken';
    $httpProvider.defaults.xsrfHeaderName = 'X-CSRFToken';

    // intercept BAD request errors
    $httpProvider.interceptors.push(function($q, $rootScope, EVENTS) {
      return {
        responseError: function(rejection) {
          // emit on 400 error (bad request, mostly form errors)
          if(rejection.status == 400){
            $rootScope.$emit(EVENTS.BAD_REQUEST, rejection);
          }
          return $q.reject(rejection);
        }
      };
    });
  })
  .config(function($locationProvider) {
    // $locationProvider.html5Mode(true);
  })
  .config(function(embedlyServiceProvider, RUNTIME) {
    if(RUNTIME.oembeds.EMBEDLY_API_KEY)
      embedlyServiceProvider.setKey(RUNTIME.oembeds.EMBEDLY_API_KEY);
  })
  .config(function ($stateProvider, $urlRouterProvider, RUNTIME) {
    $urlRouterProvider
      .otherwise("/");
    $stateProvider
      .state('index', {
        url: '/',
        reloadOnSearch : false,
        controller: 'IndexCtrl',
        templateUrl: RUNTIME.static + 'templates/index.html',
        resolve:{
          writings: function(StoryFactory){
            return StoryFactory.get({
              filters: JSON.stringify({
                tags__slug: 'highlights'
              })
            }).$promise;
          },
          news: function(StoryFactory){
            return StoryFactory.get({
              filters: JSON.stringify({
                tags__category: 'blog'
              })
            }).$promise;
          } 
        }
      })
      .state('authors', {
        url: '/authors',
        reloadOnSearch : false,
        controller: 'ItemsCtrl',
        templateUrl: RUNTIME.static + 'templates/authors.html',
        resolve: {
          items: function(ProfileFactory, $stateParams) {
            return ProfileFactory.get({
              // filters: JSON.stringify({
              //   status: 'draft',
              //   owner__username: RUNTIME.user.username,
              //   // authors__username__in: [RUNTIME.user.username]
              // })
            }).$promise;
          },
          model: function() {
            return 'profile';
          },
          factory: function(ProfileFactory) {
            return ProfileFactory;
          }
        }
      })
      .state('login', {
        url: '/login',
        reloadOnSearch : false,
        controller: 'LoginCtrl',
        templateUrl: RUNTIME.static + 'templates/login.html'
      })
      .state('draft', {
        url: '/create',
        reloadOnSearch : false,
        controller: 'DraftCtrl',
        templateUrl: RUNTIME.static + 'templates/draft.html'
      })
      .state('writing', {
        url: '/writing/:storyId',
        reloadOnSearch : false,
        controller: 'WritingCtrl',
        templateUrl: RUNTIME.static + 'templates/draft.html',
        resolve: {
          story: function(StoryFactory, $stateParams) {
            return StoryFactory.get({id: $stateParams.storyId}).$promise;
          },
        }
      });

    /*

      My stories, settings etc. (even drafts whenever available)
      ---
    
    */
    $stateProvider
      .state('me', {
        abstract: true,
        reloadOnSearch : false,
        url: '/me',
        controller: 'AuthorCtrl',
        templateUrl: RUNTIME.static + 'templates/author.html',
        resolve: {
          profile: function(ProfileFactory, RUNTIME){
            return ProfileFactory.get({
              username: RUNTIME.user.username
            }).$promise;
          }
        }
      })
      .state('me.publications', {
        url: '/publications',
        abstract:true,
        reloadOnSearch : false,
        controller: function($scope){
          $scope.urls = RUNTIME.stories.writing;
        },
        templateUrl: RUNTIME.static + 'templates/author.publications.html',
      })
      .state('me.publications.drafts', {
        url: '/drafts',
        reloadOnSearch : false,
        controller: 'ItemsCtrl',
        templateUrl: RUNTIME.static + 'templates/items.html',
        resolve: {
          items: function(StoryFactory, $stateParams) {
            return StoryFactory.get({
              filters: JSON.stringify({
                status: 'draft',
                owner__username: RUNTIME.user.username,
                // authors__username__in: [RUNTIME.user.username]
              })
            }).$promise;
          },

          model: function() {
            return 'story';
          },
          factory: function(StoryFactory) {
            return StoryFactory;
          }
        }
      });

      _.each(RUNTIME.stories.writing, function(d){
        $stateProvider
          .state('me.publications.' + d.name, {
            url: d.url,
            controller: 'ItemsCtrl',
            templateUrl: RUNTIME.static + 'templates/items.html',
              resolve: {
              items: function(StoryFactory, $stateParams) {
                return StoryFactory.get({
                  filters: d.slug? JSON.stringify({
                    tags__category: 'writing',
                    tags__slug: d.slug,
                    owner__username: RUNTIME.user.username
                  }): JSON.stringify({
                    tags__category: 'writing',
                    owner__username: RUNTIME.user.username
                  })
                }).$promise;
              },

              model: function() {
                return 'story';
              },
              factory: function(StoryFactory) {
                return StoryFactory;
              }
            }
          });
      });

    /*
      Other user stories
      ---
    */
    $stateProvider
      .state('author', {
        abstract: true,
        reloadOnSearch : false,
        url: '/author/{username:[0-9a-zA-Z\\.-_]+}',
        controller: 'AuthorCtrl',
        templateUrl: RUNTIME.static + 'templates/author.html',
        resolve: {
          profile: function(ProfileFactory, $stateParams){
            return ProfileFactory.get({
              username: $stateParams.username
            }).$promise;
          }
        }
      })
      .state('author.publications', {
        url: '',
        reloadOnSearch : false,
        controller: function($scope, profile){
          $scope.urls = RUNTIME.stories.writing;
        },
        resolve:{ // latest stories
          stories: function(profile){
            return {'value': profile};
          }
        },
        templateUrl: RUNTIME.static + 'templates/author.publications.html',
      });

      

    $stateProvider
     .state('blog', {
        url: '/blog',
        reloadOnSearch : false,
        abstract:true,
        controller: 'BlogCtrl',
        templateUrl: RUNTIME.static + 'templates/blog.html',
        
      })

      .state('blog.everything', {
        url: '',
        reloadOnSearch : false,
        controller: 'ItemsCtrl',
        templateUrl: RUNTIME.static + 'templates/items.html',
        resolve: {
          items: function(StoryFactory, $stateParams) {
            return StoryFactory.get({
              filters: JSON.stringify({
                tags__category: 'blog'
              })
            }).$promise;
          },
          model: function() {
            return 'story';
          },
          factory: function(StoryFactory) {
            return StoryFactory;
          }
        }
      })
      .state('blog.events', {
        url: '/events',
        reloadOnSearch : false,
        controller: 'ItemsCtrl',
        templateUrl: RUNTIME.static + 'templates/items.html',
        resolve: {
          items: function(StoryFactory, $stateParams) {
            return StoryFactory.get({
              filters: JSON.stringify({
                tags__category: 'blog',
                tags__slug: 'event'
              })
            }).$promise;
          },
          model: function() {
            return 'story';
          },
          factory: function(StoryFactory) {
            return StoryFactory;
          }
        }
      })
      
      // .state('events', {
      //   url: '/events',
      //   abstract:true,
      //   reloadOnSearch : false,
      //   // controller: function(){},
      //   templateUrl: RUNTIME.static + 'templates/events.html',
        
      // })

      // .state('events.everything', {
      //   url: '',
      //   controller: 'ItemsCtrl',
      //   reloadOnSearch : false,
      //   templateUrl: RUNTIME.static + 'templates/items.html',
      //   resolve: {
      //     items: function(StoryFactory, $stateParams) {
      //       return StoryFactory.get({
      //         filters: JSON.stringify({
      //           tags__category: 'event'
      //         })
      //       }).$promise;
      //     },
      //     model: function() {
      //       return 'story';
      //     },
      //     factory: function(StoryFactory) {
      //       return StoryFactory;
      //     }
      //   }
      // })

      /*
        Kind of story:writings publications
      */
      .state('publications', {
        url: '/publications',
        abstract: true,
        reloadOnSearch : false,
        controller: function($scope){
          $scope.urls = RUNTIME.stories.writing;
        },
        templateUrl: RUNTIME.static + 'templates/publications.html',
        
      })

      _.each(RUNTIME.stories.writing, function(d){
        $stateProvider
          .state('publications.' + d.name, {
            url: d.url,
            controller: 'ItemsCtrl',
            templateUrl: RUNTIME.static + 'templates/items.html',
              resolve: {
              items: function(StoryFactory, $stateParams) {
                return StoryFactory.get({
                  filters: d.slug? JSON.stringify({
                    tags__category: 'writing',
                    tags__slug: d.slug
                  }): JSON.stringify({
                    tags__category: 'writing'
                  })
                }).$promise;
              },

              model: function() {
                return 'story';
              },
              factory: function(StoryFactory) {
                return StoryFactory;
              }
            }
          });
      });

    $stateProvider
      .state('search', {
        url: '/search/:query',
        controller: function($scope, items){
          console.log(items)
          $scope.items = items.results;
        },
        reloadOnSearch : false,
        templateUrl: RUNTIME.static + 'templates/search.html',
        resolve: {
          items: function(StoryFactory, $stateParams) {
            return StoryFactory.get({id: 'search', q:$stateParams.query}).$promise;
          },
        }
      })

    $stateProvider
      .state('story', {
        url: '/story/:postId',
        controller: 'StoryCtrl',
        reloadOnSearch : false,
        templateUrl: RUNTIME.static + 'templates/story.html',
        resolve: {
          story: function(StoryFactory, $stateParams) {
            return StoryFactory.get({id: $stateParams.postId}).$promise;
          },
        }
      })


      /*
        All the rest are static pages and will download the md files directly
      */
      .state('page', {
        url: '/:name',
        controller: 'PageCtrl',
        templateUrl: RUNTIME.static + 'templates/md.html',
        resolve: {
          page: function(PageFactory, $stateParams) {
            return PageFactory.get({name: $stateParams.name});
          },
        }
      });
  });

angular.module('miller')
  .filter('prefixTemplate', function (RUNTIME) {
    return function (input) {
      return RUNTIME.static + input;
    };
  })
  .filter('bibtex', function(){
    return function (text) {
      return text? text.replace(/[\{\}]/g,''): ''
    }
  })
  /*
    Translit non ascii chars and uniform punctuations signs
  */
  .filter('slugify', function(){
    return function (text) {
      var strip  = /[^\w\s-]/g,
          hyphen = /[-\s]+/g,
          slug   = text.toLowerCase();

      var map = {
        from: 'àáäãâèéëêìíïîòóöôõùúüûñç·/_,:;', 
        to  : 'aaaaaeeeeiiiiooooouuuunc------'
      };
 
      for (var i=0, j=map.from.length; i<j; i++) {
        slug = slug.replace(new RegExp(map.from.charAt(i), 'g'), map.to.charAt(i));
      }
      return slug.replace(strip, '').trim().replace(hyphen, '-');
    };
  });
/**
 * @ngdoc service
 * @name miller.services
 * @description
 * # core
 * Resource REST API service Factory.
 */
angular.module('miller')
  /*
    Get a list of stories
  */
  .factory('StoryFactory', function ($resource) {
    return $resource('/api/story/:id/', {},{
      update: {
        method:'PUT'
      },
      patch: {
        method:'PATCH'
      }
    });
  })
  .factory('StoryTagsFactory', function ($resource) {
    return $resource('/api/story/:id/tags/', {},{
      update: {
        method:'PUT'
      }
    });
  })
  .factory('StoryDocumentsFactory', function ($resource) {
    return $resource('/api/story/:id/documents/', {},{
      update: {
        method:'PUT'
      }
    });
  })
  .factory('ProfileFactory', function ($resource) {
    return $resource('/api/profile/:username/', {},{
      update: {
        method:'PUT'
      },
      patch: {
        method:'PATCH'
      }
    });
  })
  /*
    get a list of ralreeady saved document accessible by the user
  */
  // http://localhost:8888/api/document/
  .factory('DocumentFactory', function ($resource) {
    return $resource('/api/document/:id/', {},{
      update: {
        method:'PUT'
      }
    });
  })
  .factory('CaptionFactory', function ($resource) {
    return $resource('/api/caption/:id/', {},{
      update: {
        method:'PUT'
      },
      patch: {
        method:'PATCH'
      }
    });
  })
  /*
    list tags
  */
  .factory('TagFactory', function ($resource) {
    return $resource('/api/tag/:id/', {},{
      update: {
        method:'PUT'
      }
    });
  })
  /*
    get static pages
  */
  .factory('PageFactory', function ($http, RUNTIME) {
    return {
      get: function(params) {
        return $http.get(RUNTIME.static + 'pages/' + params.name + '.md');
      }
    };
  })

  /*
    Given a querystring return a proper js object
  */
  .service('QueryParamsService', function($filter){
    return function(queryparams){
      var params={};
      queryparams.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(str,key,value) {
        params[key] = decodeURIComponent(value);
      });
      return params;
    }
  })
  .service('bibtexService', function($filter) {
    return function(json){

    }
  })
  .service('markdownItService', function($filter) {
    return function(value, language){
      var results,
          sections, // document sections.
          md = new window.markdownit(),
          linkIndex = 0;

      // set initial value for results
      results = {
        md: value,
        html:'',
        ToC: [],
        docs: [],
        footnotes: {}
      };
      // load footnotes plugin
      md
        .use(window.markdownitFootnote)
        .use(window.markdownitContainer, 'profile')
        .use(window.markdownitContainer, 'profile-committee')
        .use(window.markdownitContainer, 'profile-others')

      // console.log('RULES' , md.renderer.rules)


      // rewrite links
      md.renderer.rules.link_open = function(tokens, idx){
        var url = tokens[idx].attrGet('href');
        // console.log('LINK_OPEN', url, tokens[idx])
        if(url.trim().indexOf('doc/') === 0){
          var documents = url.trim().replace('doc/','').split(',');
          for(var i in documents){
            results.docs.push({
              _index: 'link-' + (linkIndex++), // internal id
              citation: tokens[idx + 1].content,
              slug: documents[i]
            });
          }
          if(!tokens[idx + 1].content.length){
            return '<span type="doc" lazy-placeholder="'+ documents[0] + '">';
          }
          return '<a name="'+ documents[0] +'" ng-click="fullsize(\'' +url+'\', \'doc\')"><span class="anchor-wrapper"></span>';
          // return '<a name="' + documents[0] +'" ng-click="hash(\''+url+'\')"><span class="anchor-wrapper"></span>'+text+'</a>';
        } else if(url.trim().indexOf('voc/') === 0){
          var terms = url.trim().replace('voc/','').split(',');
          for(var i in terms){
            results.docs.push({
              _index: 'link-' + (linkIndex++), // internal id
              citation: tokens[idx + 1].content,
              slug: terms[i],
              type: 'glossary'
            });
          }
          if(!tokens[idx + 1].content.length){
            return '<span type="voc" lazy-placeholder="'+ terms[0] + '">' + terms[0];
          }
          tokens[idx].attrSet('class', 'glossary');
          return '<a class="glossary" name="'+ terms[0] +'" ng-click="fullsize(\'' +url+'\', \'voc\')"><span class="anchor-wrapper"></span>';
        } else {
          return '<a href="'+url+'" target="_blank">';
        }  
      };


      md.renderer.rules.link_close = function(tokens, idx){
        if(tokens[idx-1].attrGet('href')){ // emtpy content, previous tocken was just href
          return '</span>';
        }
        return '</a>';
      }

      
      md.renderer.rules.heading_open = function(tokens, idx){
        var text = tokens[idx+1].content,
            h = {
              text: text,
              level: tokens[idx].tag.replace(/[^\d]/g, ''),
              slug: $filter('slugify')(text)
            };

        results.ToC.push(h);
        
        return '<' + tokens[idx].tag + '>'+
          // '<div class="anchor-sign" ng-click="hash(\''+ h.slug +'\')"><span class="icon-link"></span></div>'+
          '<a name="' + h.slug +'" class="anchor" href="#' + h.slug +'"><span class="header-link"></span></a>';
      }
      
      console.log('rules', md.renderer.rules);

      

      md.renderer.rules.image = function(tokens, idx){
        var src   = tokens[idx].attrGet('src'),
            title = tokens[idx].attrGet('title'),
            alt   = tokens[idx].content;

        console.log('IMAGE', src, 'title:', title, 'alt:', alt, tokens[idx])
        
        if(alt.indexOf('profile/') === 0){
          return '<div class="profile-thumb" style="background-image:url('+src+')"></div>';
        }
        return '<img src="'+ src+ '" title="'+title+'" alt="'+alt+'"/>';
      //   renderer.image = function(src, title, alt){
      //   if((alt||'').indexOf('profile/') === 0){
      //     return '<div class="profile-thumb" style="background-image:url('+src+')"></div>';
      //   }
      //   return '<img src="'+ src+ '" title="'+title+'" alt="'+alt+'"/>';
      // };
      }

      md.renderer.rules.footnote_anchor = function(tokens, idx, options, env, slf){
        var caption = slf.rules.footnote_caption(tokens, idx, options, env, slf);
        return '<span style="float:left; margin-right: 10px">'+caption+'</span>';
      }
      //   console.log('markdownItService footnote', md.renderer.rules, tokens[idx])
      //   return '<div >'
      // }
      // change rules
      md.renderer.rules.footnote_ref = function (tokens, idx, options, env, slf) {
        console.log(' md.renderer.rules.footnote_ref')
        var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);
        var caption = slf.rules.footnote_caption(tokens, idx, options, env, slf);
        return '<span footnote="'+ id + '" class="footnote-ref" caption="'+caption+'"></span>';
      };

      


      // split sections (main content and footnotes)
      sections = _(value.split(/\s*[-_]{3,}\s*\n/)).value();

      // console.log('markdownItService', sections.length)
      // get the last section (bibliographic footnotes will be there)
      if(sections.length > 1){
        results.footnotes = sections.pop();
        // override value with the reduced content
        value = sections.join('');
        // console.log('markedService footnotes: ', value)
      }

      // split value according to language if available (reduce pairs)
      if(language){
        var candidate = _(value.split(/<!--\s*(lang:[a-zA-Z_]{2,5})\s*-->/))
          .compact()
          .chunk(2)
          .fromPairs()
          .value();
        // console.log(language, candidate)
        if(candidate['lang:'+language]) {
          value = candidate['lang:'+language];
        }
        //value = value.split();
      }

      // modify results
      results.html = md.render(value);

      return results
    }
  })
  /*
    Apply marked service for custom markdown ;) Handle with care
    Example on footnotes handling, based on pandoc definition:
    ```
    Here is a footnote reference,[^1] and another.[^longnote]
 
    [^1]: Here is the footnote.
     
    [^longnote]: Here's one with multiple blocks.
        Subsequent paragraphs are indented to show that they belong to the previous footnote.
    ```
  */
  .service('markedService', function($filter) {
    return function(value, language){
      var renderer = new marked.Renderer(),
          linkIndex = 0,
          result = '',
          ToC = [],
          docs = [],
          footnotes = [];

      // split the links section and the footnotes
      var sections = _(value.split(/\s*[-_]{3,}\s*/)).value();
      console.log('markedService', sections.length)
      // get the last section (bibliographic footnotes will be there)
      if(sections.length > 1){
        var footnotes = sections.pop();
        console.log('markedService footnotes: ', footnotes)
        value = sections.join('');
        // console.log('markedService footnotes: ', value)


      }

      // split value according to language(reduce pairs)
      if(language){
        var candidate = _(value.split(/<!--\s*(lang:[a-zA-Z_]{2,5})\s*-->/))
          .compact()
          .chunk(2)
          .fromPairs()
          .value();
        // console.log(language, candidate)
        if(candidate['lang:'+language]) {
          value = candidate['lang:'+language];
        }
        //value = value.split();
      }

      

      // render the footnotes

      // collect h1,h2, hn and get the table of contents ToC
      renderer.heading = function(text, level){
        var h = {
          text: text,
          level: level,
          slug: $filter('slugify')(text)
        };
        console.log("hey", h)
        ToC.push(h);

        return '<h' + level + '>'+
          // '<div class="anchor-sign" ng-click="hash(\''+ h.slug +'\')"><span class="icon-link"></span></div>' +
          '<a name="' + h.slug +'" class="anchor" href="#' + h.slug +'"><span class="header-link"></span></a>' + 
          text + '</h' + level + '>';
      };

      // collect miller document
      renderer.link = function(url, boh, text) {
        console.log('markedService link', url);
        if(url.trim().indexOf('doc/') === 0){
          var documents = url.trim().replace('doc/','').split(',');
          for(var i in documents){
            docs.push({
              _index: 'link-' + (linkIndex++), // internal id
              citation: text,
              slug: documents[i]
            });
          }
          return '<a name="' + documents[0] +'" ng-click="hash(\''+url+'\')"><span class="anchor-wrapper"></span>'+text+'</a>';
        } else if (url.trim().indexOf('voc/') === 0){
          var terms = url.trim().replace('voc/','').split(',');
          for(var i in terms){
            docs.push({
              _index: 'link-' + (linkIndex++), // internal id
              citation: text,
              slug: terms[i],
              type: 'glossary'
            });
          }
          return '<a class="glossary" name="' + terms[0] +'" ng-click="hash(\''+url+'\')"><span class="anchor-wrapper"></span>'+text+' <span class="icon icon-arrow-right-circle"></span></a>';
        
        }
        return '<a href='+url+'>'+text+'</a>';
      };

      renderer.image = function(src, title, alt){
        if((alt||'').indexOf('profile/') === 0){
          return '<div class="profile-thumb" style="background-image:url('+src+')"></div>';
        }
        return '<img src="'+ src+ '" title="'+title+'" alt="'+alt+'"/>';
      };

      // get the new documents and save them in background if needed.
      result = marked(value, {
        renderer: renderer
      });

      return {
        html: result,
        md: value,
        ToC: ToC,
        docs: docs
      };
    }; 
  });
/**
 * @ngdoc function
 * @name miller.controller:MeCtrl
 * @description
 * # MeCtrl
 * common functions go here.
 */
angular.module('miller')
  .controller('AuthorCtrl', function ($scope, $log, profile) {
    $scope.isMe = $scope.user.username == profile.username;
    $scope.profile = profile;
    $log.log('AuthorCtrl ready, user:', $scope.user, profile);
    
  });
  
/**
 * @ngdoc function
 * @name miller.controller:BlogCtrl
 * @description
 * # BlogCtrl
 * list stories of type blogpost.
 */
angular.module('miller')
  .controller('BlogCtrl', function ($scope, $log) {
    $log.log('BlogCtrl ready');

  });
  
/**
 * @ngdoc function
 * @name miller.controller:coreCtrl
 * @description
 * # CoreCtrl
 * common functions go here.
 */
angular.module('miller')
  .controller('CoreCtrl', function ($rootScope, $scope, $log, $location, $anchorScroll, $state, $modal, $alert, localStorageService, $translate, $timeout, StoryFactory, DocumentFactory, TagFactory, RUNTIME, EVENTS) {    
    $log.log('CoreCtrl ready, user:', RUNTIME.user.username, RUNTIME);

    $scope.user = RUNTIME.user;

    $scope.hasToC = false;
    $scope.ToCEnabled = false;

    $scope.stopStateChangeStart = false; // cfr toggleStopStateChangeStart below

    $scope.toggleTableOfContents = function() {
      $scope.hasToC = !$scope.hasToC;
    };

    $scope.locationPath = '';

    // toggle stopStateChangeStart variable thus affecting the StateChangeStart event
    $scope.toggleStopStateChangeStart = function(value) {
      $log.debug('CoreCtrl > toggleStopStateChangeStart value:', value, '- current:',$scope.stopStateChangeStart)
      $scope.stopStateChangeStart = typeof value == 'boolean'? value: !$scope.stopStateChangeStart;
    };

    $scope.setToC = function(ToC) {
      $log.log('CoreCtrl > setToC data:', ToC);
      $scope.ToC = ToC;
      // $scope.ToCEnabled = false;
    };

    $scope.disableToC = function(){
      $scope.ToCDisabled = true;
    };

    // search
    $scope.search = function(searchquery){
      $log.log('CoreCtrl > search() searchquery:', searchquery);
      $state.go('search', {
        query: searchquery
      })
    } 

    // add document items to the table-of)documents
    $scope.setDocuments = function(documents) {
      $log.log('CoreCtrl > setDocuments items n.:', documents.length, documents);
      $scope.documents = _.uniq(documents, 'id');
      if($scope.qs.view) {
        // check if it's somewhere in the scope, otherwise callit
        for(var i=0,j=$scope.documents.length;i<j;i++){
          if($scope.qs.view == $scope.documents[i].short_url){
            $scope.fullsized = $scope.documents[i];
            fullsizeModal.$promise.then(fullsizeModal.show);
            break;
          }
        }
      };
    };

    // look for document by slug (internal, cached docs or ask for new one)
    $rootScope.resolve = function(slug, type, callback){
      if(type == 'voc'){
        $log.log('CoreCtrl > $scope.resolve [requesting] voc slug:', slug)
        StoryFactory.get({id: slug}, callback);
      } else {
        var matching = $scope.documents.filter(function(d){
          return d.slug == slug
        });
        if(matching.length){
          $log.log('CoreCtrl > $scope.resolve [cached] doc slug:', slug)
          callback(matching[0]);
        } else {
          $log.log('CoreCtrl > $scope.resolve [requesting] doc slug:', slug)
          DocumentFactory.get({id: slug}, callback);
        }
      }
    }

    $scope.save = function(){
      $log.log('CoreCtrl > @SAVE ...'); 
      $scope.$broadcast(EVENTS.SAVE);
    };

    $scope.update = function(key, value){
      $log.log('CoreCtrl > @UPDATE ',key,':',value,' ...'); 
      var _d = {};
      _d[key] = value;
      $scope.$broadcast(EVENTS.UPDATE, _d);
    };


    $scope.lock = function(){
      $log.log('CoreCtrl > lock .............'); 
      
    };

    $scope.unlock = function(){
      $log.log('CoreCtrl > unlock .............'); 
      
    };

    /*
      Suggest tags for writing purposes
    */
    $scope.suggestTags = function(query, options) {
      $log.log('CoreCtrl -> suggestTags', query, options);
      var filters = options || {};
      return TagFactory.get({
        filters: JSON.stringify(filters)
      }).$promise.then(function(response) {
        return response.results;
      });
    };

    /*

    */
    /*
      Set breaking news above the header.
      Cfr indexCtrl
    */
    $scope.breakingNews = [];
    $scope.setBreakingNews = function(breakingNews) {
      $scope.breakingNews = breakingNews.slice(0,2).map(function(d){
        if(d.covers && d.covers.length){
          var cover = d.covers[0];

          d.cover_url = _.get(cover, 'metadata.urls.Preview') || cover.url;
          
        }
        return d;
      });
    };

    $rootScope.$on('$stateChangeStart', function (e, state) {
      $log.log('CoreCtrl @stateChangeStart new:', state.name, '- previous:', $scope.state);
      // for specific state only.

      if($scope.stopStateChangeStart === true){
        // check the user has wirtten sometihing..
        var answer = confirm("Are you sure you want to leave this page?")
        if (!answer) {
            e.preventDefault();
        }
      }
    });

    $rootScope.$on('$stateChangeSuccess', function (e, state) {
      var h =  $location.hash();

      $log.debug('CoreCtrl @stateChangeSuccess', state.name, h);

      // clean
      $scope.ToC = [];
      $scope.documents = [];

      // the ui.router state (cfr app.js)
      $scope.state = state.name;
      $timeout($anchorScroll, 0); // wait for the next digest cycle (cfr marked directive)

      // toggle stopChanceStart if the state is among the blocking ones
      $scope.toggleStopStateChangeStart(false);


    });


    $scope.setHash = function(hash) {
      $location.hash(hash);
    };

    $scope.changeLanguage = function(key) {
      $scope.language = key;
      localStorageService.set('lang', $scope.language);
      $translate.use(key);
    };

    $scope.isWithoutAuthors = function(story) {
      return story.authors.length !== 0;
    }

    /*
      Check that the user is allowed to write contents for the given story
      (enforced on server side of course)
    */
    $scope.hasWritingPermission = function(user, story) {
      return  !!user.username && 
              user.username.length > 0 && 
              (user.is_staff || story.owner.username == user.username);
    };

    /*
      When requested, fullsize for documents.
      Cfr also locationChangeSuccess listener 
    */
    var fullsizeModal = $modal({
      scope: $scope, 
      template: RUNTIME.static + 'templates/partials/modals/fullsize.html',
      id: 'dii',
      show: false
    });
    
    $scope.$on('modal.hide', function(e,modal){
      if(modal.$id== 'dii')
        $location.search('view', null);
    });

    // 
    $rootScope.fullsize = function(slug, type) {
      $log.log('CoreCtrl -> fullsize, doc slug:', slug, type);

      if(type=="doc"){
        $location.search('view', slug);
      }
      // $scope.fullsized = doc;
      // $location.search('view', doc.short_url);
    };


    /*
      Prevent from closing
    */
    window.onbeforeunload = function (event) {
      if($scope.state && ['draft', 'writing'].indexOf($scope.state) !== -1){
        var message = 'Sure you want to leave?';
        if (typeof event == 'undefined') {
          event = window.event;
        }
        if (event) {
          event.returnValue = message;
        }
        return message;
      }
    }

    /*
      On location change, collect the parameters.
      Since this is called BEFORE statehangeSuccess, the scrolling cannot be made at this level.
    */
    $scope.$on('$locationChangeSuccess', function (e, path) {
      $log.debug('CoreCtrl @locationChangeSuccess', path, $location);
      $scope.qs = $location.search();
      $scope.locationPath = path;
      $scope.path = $location.path();

      // load fullsize
      if($scope.qs.view){
        DocumentFactory.get({id: $scope.qs.view}, function(res){
          $scope.fullsized = res;
          fullsizeModal.$promise.then(fullsizeModal.show);
        });
      }

      if($scope.qs.view && $scope.fullsized && $scope.fullsized.short_url == $scope.qs.view){
        // normal behaviour, after fullsize has been called the view param is present in location
        fullsizeModal.$promise.then(fullsizeModal.show);
      } else if(!$scope.qs.view && $scope.fullsized){
         fullsizeModal.hide()
      }
    });

    // watch 400 bad request form error. Cfr app.js interceptors.
    $rootScope.$on(EVENTS.BAD_REQUEST, function(e, rejection){
      $alert({
        placement: 'top',
        title: 'form errors', 
        'animation': 'bounceIn',
        content: _(rejection.data).map(function(d,k){
          return '<div><b>'+k+'</b>: '+d+'</div>';
        }).value().join(''),
        show: true, 
        type:'error'
      });
    });

    var timer_event_message;
    // watch for saving or MESSAGE events
    $scope.$on(EVENTS.MESSAGE, function (e, message) {
      $log.log('CoreCtrl @MESSAGE', message);
      $scope.message = message;
      if(timer_event_message)
        $timeout.cancel(timer_event_message);
      timer_event_message = $timeout(function(){
        $scope.message = null;
      }, 2000);
    });
    /*
      First load
    */
    // load language
    $scope.language = localStorageService.get('lang') || 'en_US';
    $scope.changeLanguage($scope.language);
    // load "huighlights"
    StoryFactory.get({
      filters: JSON.stringify({
        tags__slug: 'top'
      })
    }, function(data){
      $log.info('CoreCtrl breaking news loaded', data);
      $scope.setBreakingNews(data.results);
    }); 



  });
  
/**
 * @ngdoc function
 * @name miller.controller:DraftCtrl
 * @description
 * # DraftCtrl
 * handle draft writing ;)
 */
angular.module('miller')
  .controller('DraftCtrl', function ($scope, $log, $state, localStorageService, StoryFactory, EVENTS) {
    $log.debug('DraftCtrl welcome');
    
    $scope.isDraft = true;

    $scope.tags = [];

    $scope.save = function(){
      StoryFactory.save({}, {
        title: $scope.title,
        abstract: $scope.abstract,
        contents: $scope.contents,
        status: 'draft',
        tags: _.map($scope.tags, 'id')
      }, function(res) {
        $scope.$emit(EVENTS.MESSAGE, 'saved');
        $log.log('DraftCtrl -> @EVENTS.SAVE saved:', res);
        // handle redirection.
        $state.go('writing', {
          storyId: res.id
        })
        // debugger
      });
    }
    $scope.$on(EVENTS.SAVE, function() {
      $scope.$emit(EVENTS.MESSAGE, 'saving');
      $scope.save();
    });

    // handle attach tag
    $scope.attachTag = function(tag) {
      $log.log('DraftCtrl -> attachTag', tag);
      $scope.tags.push(tag);
    };

    // handle delete tad
    $scope.detachTag = function(tag) {
      $log.log('DraftCtrl -> detachTag', tag);
      // get indexOf current tag
      for(var i=0,j=$scope.tags.length;i<j;i++){
        if($scope.tags[i].id == tag.id){
          $scope.tags.splice(i, 1);
          break;
        }
      }
      // $log.log($scope.tags)
    };

    _offsetables['writing-tools'] = $('#writing-tools');

    /*
      Watch for relevant changes (i;e. trigger after n milliseconds at least)
    */

    // $scope.$watch('title', function(title){
    //   if(title && title.length) {
    //     console.log('DraftCtrl @title v', title);
    //     localStorageService.set('title', title);
    //   }
    // });

    // $scope.$watch('abstract', function(abstract){
    //   if(abstract && abstract.length) {
    //     localStorageService.set('abstract', abstract);
    //   }
    // });

    // $scope.$watch('contents', function(contents){
    //   if(contents && contents.length) {
    //     localStorageService.set('contents', contents);
    //   }
    // });

    // $scope.$watch('metadata', function(metadata){
    //   if(!_.isEmpty(metadata)) {
    //     localStorageService.set('metadata', metadata);
    //   }
    // }, true);

    /*
      load from localstorageservice
    */
    // $scope.title    = localStorageService.get('title') || '';
    // $scope.abstract = localStorageService.get('abstract') || '';
    // $scope.contents = localStorageService.get('contents') || '';
    // $scope.metadata   = localStorageService.get('metadata') || {
    //   status: 'draft',
    //   tags: [],
    //   authors: []
    // };
  });
  
/**
 * @ngdoc function
 * @name miller.controller:indexCtrl
 * @description
 * # IndexCtrl
 */
angular.module('miller')
  .controller('IndexCtrl', function ($scope, $log, writings, news) {
    $log.debug('IndexCtrl welcome', writings);

    /*
      Get the firs n sentence until the number of words are covered.
      return an array
    */
    function tokenize(text, words){
      var sentences = text.split(/[\.!\?]/);
      // console.log(text, sentences);
      return sentences;
    }

    writings.results = writings.results.map(function(d) {
      d.excerpt = d.abstract? tokenize(d.abstract, 10)[0]: '';
      return d;
    });

    $scope.coverstory = writings.results.shift();
    $scope.otherstories = writings.results;

    $scope.news = news.results.map(function(d) {
      d.excerpt = tokenize(d.abstract, 10)[0];
      return d;
    });



  });
  
/**
 * @ngdoc function
 * @name miller.controller:coreCtrl
 * @description
 * # CoreCtrl
 * common functions go here.
 */
angular.module('miller')
  .controller('ItemsCtrl', function ($scope, $log, items, model, factory, QueryParamsService) {
    $log.log('ItemsCtrl ready, n.:', items.count, '- items:',items);

    /*
      Get the firs n sentence until the number of words are covered.
      return an array
    */
    function tokenize(text, words){
      var sentences = text.split(/[\.!\?]/);
      // console.log(text, sentences);
      return sentences;
    }

    function normalizeItems(items) {
      return items
        .map(function(d){
          if(!d.abstract)
            return d;
          var sentences = tokenize(d.abstract, 10);

          d.excerpt = sentences.shift();

          if(sentences.length)
            d.difference = sentences.join('. ');

          return d;
        })
    };
    
    // update scope vars related to count, missing, and render the items
    $scope.sync = function(res){
      $scope.isLoadingNextItems = false;
      // update next
      next = QueryParamsService(res.next || '');
      console.log('ItemsCtrl > sync()', next);
      // update count
      $scope.count = res.count;
      // push items
      $scope.items = ($scope.items || []).concat(normalizeItems(res.results));
      // update missing
      $scope.missing = res.count - $scope.items.length;
    }

    $scope.more = function(){
      if($scope.isLoadingNextItems){
        $log.warn('is still loading');
        return;
      }
      $scope.isLoadingNextItems = true;
      factory.get(next, $scope.sync);
    }

    $scope.sync(items);
    
  });
  
/**
 * @ngdoc function
 * @name miller.controller:LoginCtrl
 * @description
 * # LoginCtrl
 * login!
 */
angular.module('miller')
  .controller('LoginCtrl', function ($scope, $log) {
    $log.log('LoginCtrl ready');
  });
  
/**
 * @ngdoc function
 * @name miller.controller:PageCtrl
 * @description
 * # PageCtrl
 * Ctrl for static contents, delivered in markdown.
 */
angular.module('miller')
  .controller('PageCtrl', function ($scope, $log, page) {
    $log.log('PageCtrl ready', page.status);
    // $scope.post = post;
    $scope.md = page.data;

    // colllect media
    
    // collect h1, h2, h3
  });
  
/**
 * @ngdoc function
 * @name miller.controller:coreCtrl
 * @description
 * # CoreCtrl
 * common functions go here.
 */
angular.module('miller')
  .controller('StoryCtrl', function ($rootScope, $scope, $log, story, StoryFactory, EVENTS) {
    $scope.story = story;

    // is the story editable by the current user?
    $scope.story.isWritable = $scope.hasWritingPermission($scope.user, $scope.story);

    // is the layout table or other?
    $scope.layout = 'inline';

    // set status DRAFT or PUBLIC to the document.
    $scope.setStatus = function(status){
      $log.debug('StoryCtrl -> setStatus - status:', status);
      
      if(!$scope.user.is_staff)
        return;
        
      $scope.$emit(EVENTS.MESSAGE, 'saving');

      StoryFactory.update({
        id: $scope.story.id
      }, {
        title: $scope.story.title,
        status: status
      }, function(res) {
        $scope.story.status = res.status;
        $scope.$emit(EVENTS.MESSAGE, 'saved');
        $scope.unlock();
      });
    }

    $scope.listener = function(event, data, callback) {
      $log.log('StoryCtrl > listener, event:', event);
      
      switch(event){
        case EVENTS.MARKDOWNIT_FULLSIZE:
          $rootScope.fullsize(data.slug, data.type);
          break;
        case EVENTS.MARKDOWNIT_RESOLVE:
          $rootScope.resolve(data.slug, data.type, callback);
          break;
      }
    }


    $log.log('StoryCtrl ready, title:', story.title, 'isWritable:', $scope.story.isWritable);
    // $scope.cover = _(story.documents).filter({type: 'video-cover'}).first();

    // $scope.hasCoverVideo = $scope.cover !== undefined;
    
    // guess if there's a document interview
    // cfr corectrl setDocuments function.
    $scope.setDocuments = function(items) {
      $log.log('StoryCtrl > setDocuments items n.:', items.length);
      var documents = [],
          unlinkeddocument = [];


      documents = _.compact([$scope.cover].concat(items.map(function(item){
        var _docs = story.documents.filter(function(doc){
          return doc.slug == item.slug;
        });

        if(!_docs.length){
          $log.error("StoryCtrl > cant't find any document matching the link:",item.slug);
          return null;
        }
        return angular.extend({
          citation: item.citation
        }, _docs[0]);

      })));

      $scope.$parent.setDocuments(documents.concat(unlinkeddocument));
    };
  });
  
/**
 * @ngdoc function
 * @name miller.controller:WritingCtrl
 * @description
 * # DraftCtrl
 * handle saved story writing ;)
 */
angular.module('miller')
  .controller('WritingCtrl', function ($scope, $log, $q, $modal, story, localStorageService, StoryFactory, StoryTagsFactory, StoryDocumentsFactory, CaptionFactory, DocumentFactory, EVENTS, RUNTIME) {
    $log.debug('WritingCtrl welcome', story);

    $scope.isDraft = false;
    $scope.isSaving = false;

    $scope.id = story.id;
    $scope.title = story.title;
    $scope.abstract = story.abstract;
    $scope.contents = story.contents;
    $scope.date     = story.date;
    $scope.keywords = _.filter(story.tags, {category: 'keyword'});

    
    $scope.displayedTags = _.filter(story.tags, function(d){
      return d.category != 'keyword';
    });

    $scope.metadata = {
      status: story.status,
      owner: story.owner
    };

    $scope.setStatus = function(status) {
      $scope.metadata.status = status;
      $scope.save();
    };

    /*
      Save or delete documents according to text contents.
    */
    var documentSlugs =  _.map(story.documents, 'slug');

    $scope.setDocuments = function(documents) {
      // check what to save vs what to discard.
      var saveable = documents.filter(function(d){
        return d.type != 'glossary' && documentSlugs.indexOf(d.slug) == -1;
      });

      var deletable = documents.filter(function(d){
        return documentSlugs.indexOf(d.slug) == -1;
      });

      var included = _.map(documents, 'slug');

      // console.log(documentSlugs)
      $log.log('WritingCtrl -> setDocuments()', documents.length, '- to be saved:', saveable, '- to be deleted:');
      
      documents = story.documents.filter(function(d){
        return included.indexOf(d.slug) != -1;
      });

      if(saveable.length || deletable.length){
        $q.all(_.compact(
          saveable.map(function(d) {
            var p = CaptionFactory.save({
              story: story.id,
              document: d
            }, function(res){
              $log.warn('WritingCtrl -> setDocuments() CaptionFactory.save success', res);
              documents.push(res);
            }, function(err) {
              $log.warn('WritingCtrl -> setDocuments() CaptionFactory.save failed', err);
            }).promise;
            return p;
          })
          // .concat(deletable.map(function(d) {
          //   return CaptionFactory.save({
          //     story: story.id,
          //     document: d
          //   }, function(res){
          //     console.log('saved', res);
          //   }).promise
          // }))
        )).then(function(results){
          if(results.length){
            $scope.save();
            $scope.$parent.setDocuments(documents);
          } else {
            $scope.$parent.setDocuments(documents);
          }
        });
      } else{
        var indexed = _.keyBy(story.documents, 'slug'),
            docs = _(documents).uniq('slug').map(function(d){
              return indexed[d.slug];
            }).value();
        // console.log('indexed', docs)

        $scope.$parent.setDocuments(docs);
      }
    };

    $scope.references = [];
    $scope.lookups = [];// ref and docs and urls...

    // atthach the tag $tag for the current document.
    $scope.attachTag = function(tag) {
      $log.debug('WritingCtrl -> attachTag() tag', arguments);
      $scope.isSaving = true;
      $scope.lock();
      return StoryFactory.patch({id: story.id}, {
        tags: _.map($scope.displayedTags, 'id')
      }).$promise.then(function(res) {
        $log.debug('WritingCtrl -> attachTag() tag success', res);
        $scope.unlock();
        $scope.isSaving =false;
        return true;
      }, function(){
        // error
        return false;
      });
    };

    /*
      Detach a tag that was attached before.
    */
    $scope.detachTag = function(tag) {
      $log.debug('WritingCtrl -> detachTag() tag', arguments, $scope.displayedTags);
      $scope.isSaving = true;
      $scope.lock();
      
      return StoryFactory.patch({id: story.id}, {
        tags: _.map($scope.displayedTags, 'id')
      }).$promise.then(function(res) {
        $log.debug('WritingCtrl -> detachTag() tag success', res);
        $scope.unlock();
        $scope.isSaving =false;
        return true;
      }, function(){
        // error
        return false;
      });
    };

    $scope.suggestReferences = function(service) {
      if(!service)
        DocumentFactory.get(function(){
          console.log('list');
        });
    };
    

    $scope.save = function() {
      $log.debug('WritingCtrl @SAVE');
      $scope.$emit(EVENTS.MESSAGE, 'saving');
      $scope.isSaving = true;
      $scope.lock();
      StoryFactory.update({id: story.id}, angular.extend({
        title: $scope.title,
        abstract: $scope.abstract,
        contents: $scope.contents,
        date: $scope.date
      }, $scope.metadata), function(res) {
        $log.debug('WritingCtrl @SAVE: success');
        $scope.$emit(EVENTS.MESSAGE, 'saved');
        $scope.unlock();
        $scope.isSaving =false;
        // disable stopping change status, cfr core controller
        $scope.toggleStopStateChangeStart(false);
      });
    };

    // listener for save event.
    $scope.$on(EVENTS.SAVE, $scope.save);

    // listener for contents
    $scope.$watch('contents', function(v, p){
      if(!v || v == p)
        return;
      $scope.toggleStopStateChangeStart(true);
    });

    // enable stateChengestart by default
    // $scope.toggleStopStateChangeStart(false);
  });
  

angular.module('miller').controller('EnrichModalCtrl', function ($timeout, $scope, $log, QueryParamsService, DocumentFactory, StoryFactory, OembedSearchFactory, embedService) {
  
  $log.info('EnrichModalCtrl ready with crazy scope');

  // initialize tabs here
  $scope.tabs = {
    favourite: {
      name: 'favourite',
      items: [],
      count: 0,
      next: undefined,
      isLoadingNextItems: false,
      suggest: function(query, keep){
        var $s = this;
        $log.log('tab.favourite > suggest', $s);
        $s.isLoadingNextItems = true;
        if(!keep){
          $s.next = undefined;
        }

        DocumentFactory.get($s.next || {
          filters: JSON.stringify(query.length > 2? {contents__icontains: query}: {})
        }, function(res){
          $log.log('tab.favourite > suggest loaded n.docs:', res.results.length, QueryParamsService(res.next || ''));
          
          $s.items   = $s.next? ($s.items || []).concat(res.results): res.results;
          $s.count   = res.count;
          $s.missing = res.count - $s.items.length;
          $s.next    = QueryParamsService(res.next || '');

          $s.isLoadingNextItems = false;
        });
      },
      init: function(){
        $log.log('init', this);
        this.suggest($scope.query || '');
      }
    },
    glossary: {
      name: 'glossary',
      items: [],
      count: 0,
      next: undefined,
      suggest: function(query, keep){
        var $s = this;
        $log.log('tab.glossary > suggest', $s);
        $s.isLoadingNextItems = true;
        if(!keep){
          $s.next = undefined;
        }

        StoryFactory.get($s.next || {
          filters: JSON.stringify(query.length > 2? {
            contents__icontains: query,
            tags__slug: 'glossary'
          } : {
            tags__slug: 'glossary'
          })
        },function(res){
          $log.log('tab.glossary > suggest loaded n.docs:', res.results.length, QueryParamsService(res.next || ''));
          
          $s.items   = $s.next? ($s.items || []).concat(res.results): res.results;
          $s.count   = res.count;
          $s.missing = res.count - $s.items.length;
          $s.next    = QueryParamsService(res.next || '');
          $s.isLoadingNextItems = false;
        });
      },
      init: function(){
        $log.log('init', this);
        this.suggest($scope.query || '');
      }
    },
    url: {
      name: 'url',
      items: [],
      suggest: function(url, keep){
      
      },
      init: function(){
        $log.log('init', this);
        this.suggest($scope.url || '');
      }
    },
    CVCE: {
      name: 'CVCE',
      items: [],
      count: 0,
      next: undefined,
      suggest: function(query, keep){
        var $s = this;
        $log.log('tab.CVCE > suggest', $s);
        $s.isLoadingNextItems = true;
        
        if(!OembedSearchFactory.CVCE){
          $log.error('OembedSearchFactory.CVCE does not exist');
          return;
        }

        OembedSearchFactory.CVCE({
          q: query
        }).then(function(res){
          $log.log('tab.CVCE > suggest loaded n.docs:', res.data.results);
          $s.items = res.data.results;
          $s.count = res.data.count;
          $s.isLoadingNextItems = false;
          // scope.suggestMessage = '(<b>' + res.data.count + '</b> results)';
        });
      },
      init: function(){
        $log.log('init', this);
        this.suggest($scope.query || '');
      }
    },
  };

  var timer_preview;
  $scope.previewUrl = function(url){
    if(timer_preview)
      $timeout.cancel(timer_preview);
    // check url
    var regexp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&&#37;@!\-\/]))?/;
    if(!regexp.test(url)){
      $log.error('::mde -> previewUrl() url provided:', url, 'is not valid');
      return false;
    }
    url = url.replace('#', '.hash.');
    timer_preview = $timeout(function(){
      $log.debug('::mde -> previewUrl() url:', url);
      $scope.suggestMessage = '(loading...)';
      embedService.get(url).then(function(data){
        $log.debug(':: mde -> previewUrl() received:', data)
        $scope.embed = data;
        $scope.suggestMessage = '(<b>done</b>)';
      });
    }, 20);
  };

  

  $scope.setTab = function(tabname){
    $log.log('EnrichModalCtrl -> setTab() tab.name:', tabname);

    $scope.tab = $scope.tabs[tabname];
    $scope.tab.init()
  }


  $scope.suggest = function(query){
    $log.log('EnrichModalCtrl -> suggest() q:', query);
    $scope.tab.suggest(query);
  }

  $scope.more = function(query, tab){
    $log.log('EnrichModalCtrl -> more()');
    $scope.tab.suggest(query, true);
  }


  
  $scope.setTab('favourite');


});
/**
 * @ngdoc function
 * @name miller.directives:lazy
 * @description
 * # marked
 * transform markdown data in miller enhanced datas
 */
angular.module('miller')
  .directive('lazyImage', function ($log) {
    return {
      restrict : 'A',
      scope: {
        src: '='
      },
      link : function(scope, element, attrs) {
        $log.log(':::lazy on ',scope.src);

        element.addClass('lazy-box').css({
          'background-color': '#B7B2B2',
        }).html('<div class="loading">...</div>');
        
        function wakeup(){
          element.css({
            'background-size': attrs.size || 'cover',
            'background-position': 'center center',
            'background-repeat': 'no-repeat',
            'background-image': 'url(' + scope.src + ')'
          });
          element.find('.loading').hide();
        }

        scope.$watch('src', function(v){
          if(v)
            wakeup(); // or start watching for in page
        });

      }
    };
  })
  /*
    lazy placeholder for document or for stories, filled when needed only.
  */
  .directive('lazyPlaceholder', function($log, $rootScope, $compile, RUNTIME) {
    return {
      //transclude: true,
      scope:{
        
      },
      templateUrl: RUNTIME.static + 'templates/partials/placeholder.html',
      link : function(scope, element, attrs) {
        var slug = element.attr('lazy-placeholder'),
            type = element.attr('type');

        scope.type = type;
        
        $log.log('⏣ lazy-placeholder on type:', type, '- slug:',slug);
        
        scope.complete = function(res){
          // add to this local scope
          if(res){
            scope.resolved = res;
            $log.log('⏣ lazy-placeholder resolved for type:', type, '- slug:',slug, res);
            // force recompilation
            $compile(element.contents())(scope);
          } else {
            $log.error('⏣ lazy-placeholder cannot find', slug );
          }
        }

        if($rootScope.resolve && typeof slug=='string'){
          $rootScope.resolve(slug, type, scope.complete);
        }

        scope.fullsize = function(slug, type){
          $rootScope.fullsize(slug, type);
        }
        
      }
    }
  });
/**
 * @ngdoc function
 * @name miller.directives:marked
 * @description
 * # marked
 * transform markdown data in miller enhanced datas
 */
angular.module('miller')
  // .directive('markdown', function($compile, $log, $location){
  //   return {
  //     restrict : 'A',
  //     scope:{
  //       markdown: '=',
  //     },
  //     link : function(scope, element, attrs) {
  //       if(scope.markdown && scope.markdown.length) {
  //         element.html(marked(scope.markdown));
  //         $compile(element.contents())(scope);
  //       }
  //     }
  //   };
  // })
  // .directive('markedLanguage', function($compile, $log, $location){
  //   return {
  //     restrict : 'A',
  //     scope:{
  //       markedLanguage: '=',
  //     },
  //     link : function(scope, element, attrs) {
  //       if(scope.markdown && scope.markdown.length) {
  //         element.html(marked(scope.markdown));
  //         $compile(element.contents())(scope);
  //       }
  //     }
  //   };
  // })
  .directive('footnote', function($compile){
    return {
      restrict : 'A',
      scope:{
        caption: '=',
        footnote: '='
      },
      require: "^?markdownit",
      template: '<span class="footnote"><a ng-click="toggleFootnote()" style="cursor:pointer">{{caption}}</a><div class="footnote-contents" ng-show="isOpened"></div></span>',
      link: function(scope, element, attrs) {
        var footnoteSl = '#fn'+scope.caption + ' p', // footnote jquery selector
            contents = $(footnoteSl).clone(),
            wrapper = element.find('.footnote-contents');
        
        

        wrapper.html(contents);
        $compile(wrapper.contents())(scope);
        
        scope.isOpened = false;

        scope.toggleFootnote = function(){
          console.log('::footnote > toggleFootnote')
          scope.isOpened = !scope.isOpened;
          // if(scope.isOpened && !scope.isFilled){
            
          //   scope.isFilled = true;
          // }
        }

        scope.fullsize = function(slug, type){
          scope.$parent.fullsize(slug, type);
        }

      }
    }
  })
  .directive('embedit', function($sce){
    return {
      restrict : 'A',
      scope:{
        embedit: '=',
        stretch: '=',
        language: '='
      },
      link: function(scope, element, attrs){
        if(scope.language && typeof scope.embedit == 'object'){
          element.html(scope.embedit[scope.language]|| '');
        } else {
          element.html(scope.embedit);
        }
        if(scope.stretch){
          element.find('iframe').width('100%').height('100%');
        }

      }
    }
  })
  // main markdown directive, almost always used
  .directive('markdownit', function ($compile, $log, $location, markdownItService, EVENTS) {
    return {
      restrict : 'A',
      scope:{
        markdownit: '=',
        settoc: '&',
        setdocs: '&',
        language: '=',
        listener: '&'
      },
      link : function(scope, element, attrs) {
        var entities = [],
            annotable = false,
            
            ToC = [],
            docs = [],
            footnotes = {};

        scope.hash = function(what) {
          $location.hash(what);
        };
        
        scope.fullsize = function(slug, type){
          if(scope.listener){
            scope.listener({
              event: EVENTS.MARKDOWNIT_FULLSIZE, 
              data: {
                slug: slug.replace(/^.*\//, ''),
                type: type
              }
            });
          }
        }

        scope.resolve = function(slug, type, notify){
          if(scope.listener){
            scope.listener({
              event: EVENTS.MARKDOWNIT_RESOLVE, 
              data: {
                slug: slug,
                type: type
              },
              callback: notify
            });
          }
        }
        
        function parse() {
          if(!scope.markdownit || !scope.markdownit.length){
            $log.warn(':: markdownit parse() without any markdown text! Check the value for `markdownit`');
            return;
          }
          var results  = markdownItService(scope.markdownit, scope.language);

          element.html(results.html);
          $compile(element.contents())(scope);
          if(scope.settoc)
            scope.settoc({ToC:results.ToC});
          if(scope.setdocs)
            scope.setdocs({items:results.docs});
        };

        // watch language and reparse everything when needed.
        if(scope.language)
          scope.$watch('language', function(language){
            if(language)
              parse();
          });
        else
          parse();
      }
    }
  })

  .directive('marked', function ($compile, $log, $location, markedService) {
   return {
      restrict : 'A',
      scope:{
        marked: '=',
        settoc: '&',
        setdocs: '&',
        language: '='
      },
      link : function(scope, element, attrs) {
        var entities = [],
            renderer = new marked.Renderer(),

            annotable = false,
            ToC = [],
            docs = [],
            lp; // previous opened heading level, for ToC purposes

        scope.hash = function(what) {
          $location.hash(what);
        };

        scope.miller = function(url){
          // ?
        };
        
        function init(){
          if(!scope.marked || !scope.marked.length){
            $log.warn(':: marked init(), no text to be marked');
            return;
          }
          var rendered  = markedService(scope.marked, scope.language);

          element.html(rendered.html);
          $compile(element.contents())(scope);
          if(scope.settoc)
            scope.settoc({ToC:rendered.ToC});
          if(scope.setdocs)
            scope.setdocs({items:rendered.docs});
        }

        if(scope.language)
          scope.$watch('language', function(language){
            if(language)
              init();
          });
        else
          init();
      }
    };
  });
/**
 * @ngdoc function
 * @name miller.directives:lazy
 * @description
 * # marked
 * transform markdown data in miller enhanced datas
 */
angular.module('miller')
  .directive('mde', function ($log, $timeout, $modal,  $filter, DocumentFactory, StoryFactory, OembedSearchFactory, embedService, markedService, RUNTIME) {
    return {
      restrict: 'AE',
      scope: {
        mde: '=',
        settoc: '&',
        setdocs: '&'
      },
      templateUrl: RUNTIME.static + 'templates/partials/mde.html',
      link: function(scope, el, attributes){
        // active tab
        scope.activeStates = [];

        // preview enabled or disabled
        scope.isPreviewEnabled = false;

        // secretize bookmarks. Automatically clean the code sent to initialvalue
        // will set SetBookmarks 
        

        var simplemde,
            timer,
            timer_recompile,
            timer_preview,
            wand = el.find('.wand').hide(),
            textarea = el.find('textarea').hide(),
            toolbox =  el.find('.toolbox').hide(),
            lookups=[],
            referenceModal = $modal({
              scope: scope,
              title: 'h',
              controller: 'EnrichModalCtrl',
              template: RUNTIME.static + 'templates/partials/modals/mde-enrich.html',
              show: false
            });
            
        function init(){
          textarea.show();
          wand.show();
          toolbox.show();

          simplemde = new SimpleMDE({
            element: textarea[0],
            spellChecker: false,
            status: false,
            toolbar: false,
            toolbarTips: false,
            initialValue: scope.mde
          });

          // assign overlay
          // simplemde.codemirror.addOverlay({
          //     name: 'invisibles',
          //     token:  function nextToken(stream) {
          //         var ret,
          //             spaces  = 0,
          //             peek    = stream.peek() === ' ';

          //         if (peek) {
          //             while (peek && spaces < Maximum) {
          //                 ++spaces;

          //                 stream.next();
          //                 peek = stream.peek() === ' ';
          //             }

          //             ret = 'whitespace whitespace-' + spaces;
          //         } else {
          //             while (!stream.eol() && !peek) {
          //                 stream.next();

          //                 peek = stream.peek() === ' ';
          //             }

          //             ret = 'cm-eol';
          //         }

          //         return ret;
          //     }
          // });

          
          var cursor,
              pos,
              stat,
              followCursor,
              // table of contents hash. Are there differences?
              pcursor;// = simplemde.codemirror.display.find('.Codemirror-cursor');


          // listener codemirror@cursorActivity
          function move(){
            if(timer)
              clearTimeout(timer);

            timer = setTimeout(function(){

              if(simplemde.codemirror.display.cursorDiv.firstChild){
                // console.log('moving cruising', simplemde.codemirror.getSelection(), 'crui')
                
                cursor = {
                  top: simplemde.codemirror.display.cursorDiv.firstChild.offsetTop,
                  left: simplemde.codemirror.display.cursorDiv.firstChild.offsetLeft,
                  height: simplemde.codemirror.display.cursorDiv.firstChild.offsetHeight
                };
                wand.css('transform', 'translateY('+(cursor.top+cursor.height-20)+'px)');
                
                if(followCursor)
                  toolbox.css('transform', 'translate('+(cursor.left)+'px,'+(cursor.top)+'px)');

                // check cursor position: is it inside a BOLD or ITALIC?
                pos = simplemde.codemirror.getCursor("start");
                stat = simplemde.codemirror.getTokenAt(pos);
                // $log.log('     ', stat)
                scope.activeStates = (stat.type || '').split(' ');
                scope.$apply();
              }
            }, 20);
            

          }

          // // listener for the selection object.
          var _isSelection;
          function beforeSelectionChange(e, sel){
            var isSelection = (sel.ranges[0].head.ch - sel.ranges[0].anchor.ch) !== 0;
            // selection is on and it has changed. 
            if(isSelection && isSelection != _isSelection){
              toolbox.addClass('active');
            } else if(!isSelection && isSelection != _isSelection){
              toolbox.removeClass('active');
            }
            
            _isSelection = isSelection
          }

          

          /*
            Recompile with marked, analyzing the documents and
            the different stuff in the contents.
          */
          var _ToCHash,
              _docsHash;

          function recompile(){
            // $log.debug('::mde -> recompile() ...');
            var marked   = markedService(simplemde.value()),
                ToCHash = md5(JSON.stringify(marked.ToC)),
                docsHash = md5(_.map(marked.docs,'slug').join('--'));
            
            if(_ToCHash != ToCHash){
              $log.log('::mde -> recompile() items ToC:',marked.ToC.length, 'docs:', marked.docs.length, ToCHash);
              scope.settoc({items:marked.ToC});
            }
            if(_docsHash != docsHash){
              $log.log('::mde -> recompile() items docs:', _docsHash);
              scope.setdocs({documents: marked.docs});
            }
            // scope.$apply();
            // apply toc hash not to reload twice
            _ToCHash = ToCHash;
            _docsHash = docsHash;
          }

          // listener codemirror@update
          // update event, recompile after n milliseconds
          function onUpdate(e){
            var value = simplemde.value();
            if(textarea.val() != value){
              scope.mde = value; // set model
              textarea.val(value); // get headers after some time
            }
            move();
            if(timer_recompile)
              clearTimeout(timer_recompile);
            timer_recompile = setTimeout(function(){
              recompile();
              scope.$apply()
            }, 500);  
          }

          // listener codemirror@changeEnd
          function onChange(e, change){
            var from = change.from;
            var text = change.text.join("\n");
            var removed = change.removed.join("\n");
            var to =  simplemde.codemirror.posFromIndex(simplemde.codemirror.indexFromPos(from) + text.length);

            simplemde.codemirror.markText(from, to, {
              className: 'mde-modified'
            })
          };

          // listener codemirror@focus
          function onFocus(e) {
            toolbox.show();
            wand.show()
          };
          // listener codemirror@focus
          function onBlur(e) {
            toolbox.hide();
            wand.hide();
          };
          // listener
          function beforeChange(){
            // debugger
          }

          simplemde.codemirror.on('update', onUpdate);
          simplemde.codemirror.on('cursorActivity', move);
          simplemde.codemirror.on('beforeSelectionChange', beforeSelectionChange);
          simplemde.codemirror.on('beforeChange', beforeChange);
          simplemde.codemirror.on('change', onChange);
          // simplemde.codemirror.on('focus', onFocus);
          // simplemde.codemirror.on('blur', onBlur);
          
          // if a settoc, ask for recompiling
          if(scope.settoc)
            timer_recompile = setTimeout(recompile, 20);
        
        }

        // listen window event, instance specific
        // var _isToolbarVisible;
        // $(window).on('scroll.mde', function(){
        //   var toolbarOffset = el.offset().top - st,
        //       isToolbarVisible =  toolbarOffset > 100;

        //   if(!isToolbarVisible)
        //     toolbox.css('transform', 'translate(0px,'+(100 - toolbarOffset)+'px)');
        //   else if(isToolbarVisible!==_isToolbarVisible)
        //     toolbox.css('transform', 'translate(0px,0px)');
          

        //   _isToolbarVisible = isToolbarVisible;
        // });

        // // on destry, destroy scroll event
        // scope.$on("$destroy", function(){
        //   $(window).off('scroll.mde');
        // });

        /*
          Modal tabs
        */

        // open modal tab and store previously open tab in this scope.
        scope.setTab = function(tab){
          scope.tab = tab;
        };
        scope.tab = 'CVCE';

        // preview url
        scope.previewUrl = function(url){
          if(timer_preview)
            $timeout.cancel(timer_preview);
          // check url
          var regexp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&&#37;@!\-\/]))?/;
          if(!regexp.test(url)){
            $log.error('::mde -> previewUrl() url provided:', url, 'is not valid');
            return false;
          }
          url = url.replace('#', '.hash.');
          timer_preview = $timeout(function(){
            $log.debug('::mde -> previewUrl() url:', url);
            scope.suggestMessage = '(loading...)';
            embedService.get(url).then(function(data){
              $log.debug(':: mde -> previewUrl() received:', data)
              scope.embed = data;
              scope.suggestMessage = '(<b>done</b>)';
            });
          }, 20);
        };

        // suggest from different archives, w timeout
        var previous ;
        scope.suggestResults = [];
        scope.suggestMessage = '';
        scope.suggest = function(query, service){
          $log.log('::mde -> suggest()', scope.query, query, OembedSearchFactory);
          
          if(query.length < 3) {
            scope.suggestMessage = '(write something more)';
            scope.suggestResults = [];
            return;
          }

          // reset counters and lookups
          scope.lookups = [];
          scope.count = 0;
          scope.next = undefined;

          scope.suggestMessage = '(loading...)';
          // internal search
          if(service == 'favourite'){
            DocumentFactory.get({
              filters: JSON.stringify(query.length > 2? {contents__icontains: query}: {})
            },function(res){
              $log.log('::mde -> showReferenceModal documents loaded', res.results.length);

              scope.lookups = res.results;
              scope.suggestMessage = '(<b>' + res.count + '</b> results)';
            });
            return;
          } else if(service == 'glossary') {
            var params = {
              tags__slug: 'glossary'
            }
            if(query.length > 2)
              params.contents__icontains = query;

            StoryFactory.get({
              filters: JSON.stringify(params)
            },function(res){
              $log.log('::mde -> showReferenceModal documents loaded', res.results.length);

              scope.glossary = res.results;
              scope.suggestMessage = '(<b>' + res.count + '</b> results)';
            });
            return;
          } 

          

            // external search
          
          if(OembedSearchFactory[service])
            OembedSearchFactory[service](query).then(function(res){
              scope.suggestResults = res.data.results;
              scope.suggestMessage = '(<b>' + res.data.count + '</b> results)';
            });
          
        };

        // open
        scope.showReferenceModal = function(){
          if(scope.activeStates.indexOf("link") !== -1){
            $log.warn('oh dear, you should not click on it')
            return;
          }
          // if there is already a link, should add it.
          referenceModal.$promise.then(function(){
            $log.log('::mde -> showReferenceModal called');
            referenceModal.show();
          });
          
          // DocumentFactory.get(function(res){
          //   $log.log('::mde -> showReferenceModal documents loaded', res.results.length);

          //   scope.lookups = res.results;
          // });
          // console.log(simplemde)
          // debugger
        };

      

        scope.addDocument = function(type, contents, reference, url, embed){
          var slug;

          $log.debug('::mde -> addDocument() type:', type);

          if(type=='bibtex'){
            $log.debug('    reference:', bibtexParse.toJSON(reference));
            return;
          }

          if(type=='glossary'){
            referenceModal.hide();
            SimpleMDE.drawLink(simplemde,{
              // text: scope.selectedDocument.title,
              url: 'voc/' + scope.selectedDocument.slug
            });
            return;
          }
          // case it is an url
          if(type=='url'){
            if(!embed.title){
              referenceModal.hide();
              SimpleMDE.drawLink(simplemde,{
                url: url
              });
              return;
            }
            slug = $filter('slugify')(embed.title).substr(0,100);

            DocumentFactory.save({
              title: embed.title,
              contents: JSON.stringify(embed),
              type: (embed.type|| 'link').toLowerCase(),
              slug:  slug,
              url: url
            }, function(res){
              $log.debug('::mde -> addDocument() document saved:', res.slug, res.id, res.short_url);
              if(res.slug){
                referenceModal.hide();
                SimpleMDE.drawLink(simplemde,{
                  url: 'doc/' + res.slug
                });
              }
            }, function(err){
              // ignore duplicates (slug field) and put it directly.
              if(err.data.slug && _.keys(err.data).join('') == 'slug'){
                SimpleMDE.drawLink(simplemde,{
                  url: 'doc/' + slug
                });
              } else {
                $log.error('::mde -> addDocument() cannot save document', err);
              }
            });
            return;
          }

          if(!scope.selectedDocument) {
            $log.warn('::mde -> addDocument() no document selected');
            return;
          }

          if(type == 'CVCE'){
            slug = 'cvce/'+scope.selectedDocument.details.doi;
            $log.debug('::mde -> addDocument() doc:', slug);
            DocumentFactory.save({
              title: scope.selectedDocument.title,
              contents: JSON.stringify(scope.selectedDocument),
              type: (scope.selectedDocument.type|| 'link').toLowerCase(),
              slug:  slug,
              url: url
            }, function(res){
              $log.debug('::mde -> addDocument() document saved:', res.slug, res.id, res.short_url);
              if(res.slug){
                referenceModal.hide();
                SimpleMDE.drawLink(simplemde,{
                  url: 'doc/' + res.slug
                });
              }
            }, function(err){
              // debugger
              // ignore duplicates and put it directly.
              if(err.data.slug){
                $log.debug('::mde -> addDocument() document already saved:', slug);
                SimpleMDE.drawLink(simplemde,{
                  url: 'doc/' + slug
                });
              }
            });
            return;
          }

          // document type
          if(scope.selectedDocument.type == 'bibtex'){
            
            SimpleMDE.drawLink(simplemde,{
              // text: '('+ scope.selectedDocument.metadata.author + ' '+ scope.selectedDocument.metadata.year +')',
              url: 'doc/' + scope.selectedDocument.slug
            });
          }
          // the document has been selected.
          $log.debug('::mde -> addDocument() doc:', scope.selectedDocument);
          // lock ui
          // draw link at the end of the db
          referenceModal.hide();
          SimpleMDE.drawLink(simplemde,{
            url: 'doc/' + scope.selectedDocument.slug
          });
        };

        scope.selectDocument = function(doc){
          $log.log('::mde -> selectDocument()', doc.url);

          if(scope.selectedDocument && scope.selectedDocument.url == doc.url){
            // $log.log('::mde -> selectDocument() unselecting previous', doc.url);
            scope.isSomethingSelected = false;
            scope.selectedDocument = false;
          } else if(scope.selectedDocument){
            // $log.log('::mde -> selectDocument() change selection from', scope.selectedDocument.title);
            scope.isSomethingSelected = true;
            scope.selectedDocument = doc;
          } else {
            // $log.log('::mde -> selectDocument() as new item');
            scope.isSomethingSelected = true;
            scope.selectedDocument = doc;
          }
          
          
        };

        scope.action = function(action) {
          if(action == 'togglePreview'){
            scope.isPreviewEnabled = !scope.isPreviewEnabled;
          }
          SimpleMDE[action](simplemde);
        };
        
        // take into account custom font-face rendering.
        $timeout(init, 500);
        return;


      }
    };
  });